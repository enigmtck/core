# Enigmatick End-to-End Encryption Design

Enigmatick is an ActivityPub server designed as a testbed for implementing end-to-end encryption using the ActivityStreams vocabulary (to the extent reasonable). Some liberties have been taken in the current implementation to enable a server to identify and appropriately handle encrypted notes (`EncryptedNote` type) separately from plaintext notes (`Note` type). I've tried to keep those idiosyncrasies to a minimum and I'm open to adjusting the implementation to better align with the standard. In all cases where a change might make sense, please open an Issue on this repository.

## Overview

I've integrated the [`vodozemac`](https://github.com/matrix-org/vodozemac) Rust library as the primary mechanism used to provide asymmetric encryption between ActivityPub participants. Design decisions have been made to accommodate the way that library operates.

Additionally, symmetric encryption is handled by the [`orion`](https://github.com/orion-rs/orion) cryptographic suite. As I've built out this service, this library has somewhat lagged other options and is not as thoroughly vetted as I'd like; I may change this. Orion provides encryption of data stored on the server to facilitate client (browser) access and is not critical to the fundamental design of the cryptographic system described here.

## System Design

The overall system is comprised of these components:

1. Individual Olm accounts created for the sender and the receiver. In Enigmatick, these exist as symmetrically encrypted blobs stored in the `core` database(s).
2. New `Instrument` types for: `OlmIdentityKey` and `OlmOneTimeKey`. There are also other new instruments defined (e.g., `OlmSession`, `VaultItem`, etc.) that are specific to the Enigmatick client implementation and are not specifically relevant to the ActivityPub exchanges. While Enigmatick stores and manages those as symmetrically-encrypted `Instrument` objects, it's plausible that a fat client, for example, would handle the associated requirements differently.
3. A new `/keys` endpoint for all encryption-enabled `Actor` objects. This endpoint is used to deliver `OlmIdentityKey` and `OlmOneTimeKey` instruments to message-sending actors.
4. API methods and associated storage facilities to manage `OlmOneTimeKey` records generated by the client (the browser in the case of Enigmatick).
4. A new object type, `EncryptedNote`. This object currently mirrors all of the characteristics of `Note` with the only difference being that the `content` field is intended to be unreadable without the aid of an instrument.

### Account Creation

An Olm account is created when an Enigmatick user is created. This account is maintained within Enigmatick as a part of the `Actor` object for local actors. It is a private field (symmetrically encrypted by the client) and should not be exposed as a general ActivityPub attribute.

```sql
enigmatick=> select ek_olm_pickled_account, ek_olm_identity_key from actors where ek_username='clark';
-[ RECORD 1 ]----------+-------------------------------------------------------------------------------------
ek_olm_pickled_account | g6m36NbXJ6kzgWtwYZ9J9v1pm1rfBPMGZpL7OeMfOJN4ND3ZnF9NGqxvJwnTaCIxTcpkZrSqxkZxK2YEGvnN.
                       |.vEW//xSES/twWqbVx01kDhEm1HyY9uVqDOqQr1HL3XPs3y3ZxpGVk2m2DfbO6o7hj+OHzys4js799h4IuKsj.
...
ek_olm_identity_key    | 7jImYabiufIUOE4QjCfabJT/h1OhoMLztxqzEBqyn0w
```

The bulk of the user data is set by the client when it's created. These are the code lines that create the Olm account:

```rust
use vodozemac::olm::Account;

let account = Account::new();
let olm_identity_key = Some(account.curve25519_key().to_base64());
let olm_pickled_account = serde_json::to_string(&account.pickle()).unwrap();
```

### Olm One-Time-Key Generation

A one-time-key is needed to start an encrypted session with another user. To facilitate this, I've added a `/keys` endpoint to the Enigmatick actor objects.

```bash
> curl -sH "Accept: application/activity+json" "https://enigmatick.social/user/clark/keys" | jq
{
  "@context": "https://www.w3.org/ns/activitystreams",
  "type": "Collection",
  "id": "https://enigmatick.social/user/clark/keys",
  "totalItems": 25
}
```

A signed request to this endpoint with `?otk=true` will provide a collection with the remote user's `OlmIdentityKey` and an `OlmOneTimeKey` to use to start an encrypted conversation.

```bash
> curl -H "Accept: application/activity+json" "https://enigmatick.social/user/clark/keys?otk=true" | jq
{
  "@context": "https://www.w3.org/ns/activitystreams",
  "type": "Collection",
  "id": "https://enigmatick.social/collections/84567924-0848-4323-b7cd-0273f13030d7",
  "totalItems": 2,
  "items": [
    {
      "type": "OlmOneTimeKey",
      "id": "https://enigmatick.social/instruments/da267575-3787-4df2-ac11-e734f9f32d38",
      "content": "GVGzbKaznnKzgV5+/xRDfdx2lbMP0qBfcTaSV1+BATY"
    },
    {
      "type": "OlmIdentityKey",
      "id": "https://enigmatick.social/user/clark#identity-key",
      "content": "7jImYabiufIUOE4QjCfabJT/h1OhoMLztxqzEBqyn0w"
    }
  ]
}
```

The `OlmOneTimeKey` keys are created by the client and pushed to the server periodically. The frequency and nature of that process is an arbitrary implementation detail and is not critical to the ActivityPub exchange. What is important is that those keys be generated by the client and stored on the server in some way.

```rust
#[wasm_bindgen]
pub async fn add_one_time_keys(params: OtkUpdateParams) -> Option<String> {
    authenticated(move |_: EnigmatickState, profile: Profile| async move {
        let username = profile.username;
        let url = format!("/api/user/{username}/otk");

        let data = serde_json::to_string(&params).unwrap();
        log(&format!("{data:#?}"));
        send_post(url, data, "application/json".to_string()).await
    })
    .await
}
```

### Olm Session Initiation

Using the keys provided by the `/keys` endpoint, an actor may create a new Olm session with the recipient.

Below is a snippet from the `enigmatick_wasm` module in the `enigmatick-web` repository.

```rust
pub async fn encrypt_note(params: &mut SendParams) -> Result<()> {
    let mut session = if params.conversation.is_some() {
        get_olm_session(params.conversation.clone().unwrap()).await?
    } else {
        create_olm_session(params).await?
    };

    log(&format!("Olm Session\n{session:#?}"));

    params.set_vault_item(params.get_content().clone().try_into()?);
    params.set_content(
        serde_json::to_string(&session.encrypt(params.get_content()))
            .map_err(anyhow::Error::msg)?,
    );
    params.set_olm_session(ApInstrument::try_from(session)?);

    Ok(())
}
```

There is more happening than meets the eye (review the repository for details). The end result is an `EncryptedNote` object that is passed to the recipient.

```json
{
  "cc": [],
  "id": "https://enigmatick.social/objects/[some-uuid]",
  "to": [
    "https://enigmatick.social/user/clark"
  ],
  "tag": [
    {
      "href": "https://enigmatick.social/user/clark",
      "name": "@clark@enigmatick.social",
      "type": "Mention"
    }
  ],
  "type": "EncryptedNote",
  "content": "{\"type\":0,\"body\":\"AwogZNVPkw0ZXxKnhDU0Tjf4NWX/2OvFTSx2IWxS1S1VK3gSINVvl3MHxmTBwyGVO+Bc8QqAP
ARVDTsPoCuRrrcEn7hxGiAFhZIDySEb5XYDxjEtbkueCuMfNs/7plG3FBweZdUfHiJnBAogDJQPFOjpBU81Hk4xildg7kNyTwn5Ntotk22UOEJ
vUg8QACIghqtjcoYnNKMk5unzO3qa0ckq/WihX18uwwbGN44Wm/8Kk6xgFQ7Cbl5q1DbNcPm6QlFnaJtyMveLLa7EzAJuUg\"}",
  "@context": "https://www.w3.org/ns/activitystreams",
  "published": "2024-11-24T23:23:14.252Z",
  "attachment": [],
  "instrument": [
    {
      "id": "https://enigmatick.social/instruments/[some-uuid]",
      "type": "OlmIdentityKey",
      "content": "BYWSA8khG+V2A8YxLW5LngrjHzbP+6ZRtxQcHmXVHx4"
    }
  ],
  "attributedTo": "https://enigmatick.social/user/jdt"
}
```

The above example is from my database, but it's based on the raw JSON sent by the client (hence the IDs aren't set). I removed the extraneous data the client also sends (`OlmAccount`, `OlmSession`, and `VaultItem` instruments). Those are stripped by the server before sending to the recipient's server, but are captured on the local server for persistence. That is an implementation detail specific to Enigmatick.

I'm not committed to transferring the `OlmIdentityKey` in this exchange. It may be more powerful to require the receiver to retrieve that key from the source explicitly, in a similar manner to how ActivityPub uses HTTP signatures to validate `POST` messages. Initially, I used a type of `Note` and the presence of the `OlmIdentityKey` to signal to the client that decryption was required. But with the dedicated `EncryptedNote` type, that's no longer a concern.

...to be continued.
